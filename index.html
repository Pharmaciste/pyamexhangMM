<script>
/* ====== Config ====== */
const OPEN_SEC   = 65 * 60;           // 65:00
const CLOSED_SEC = 2 * 3600 + 1;      // 2:00:01
const CYCLE_SEC  = OPEN_SEC + CLOSED_SEC;
const CYCLE_MS   = CYCLE_SEC * 1000;
const DOTS = 5;

/* === Point d’ancrage + base de numérotation ===
   - ANCHOR = aujourd’hui 20:14:06 (heure locale)
   - BASE_CYCLE = numéro à afficher pour la 1re ouverture >= ANCHOR
     (57 pour coller à ta capture). Change-le si besoin. */
const ANCHOR = new Date();
ANCHOR.setHours(20, 14, 6, 0);
const anchor_ms = ANCHOR.getTime();
const BASE_CYCLE = 57;

/* DOM */
const elClock     = document.getElementById('clock');
const elUntil     = document.getElementById('until');
const elStatus    = document.getElementById('status');
const elStatusBig = document.getElementById('statusBig');
const elSub       = document.getElementById('subtitle');
const elNext      = document.getElementById('nextTimes');
const ledsWrap    = document.getElementById('leds');
const leds        = ledsWrap.children;
const scheduleDiv = document.getElementById('schedule');
const patchDate   = document.getElementById('patchDate');

/* Utils */
const pad = n => String(n).padStart(2,'0');
const fmtHMS = s => { s = Math.floor(s); return `${pad((s/3600)|0)}:${pad(((s%3600)/60)|0)}:${pad(s%60)}`; };
const fmtMMSS = s => { s = Math.floor(s); return `${pad((s/60)|0)}:${pad(s%60)}`; };
const pretty = ms => new Date(ms).toLocaleString('en-GB', { dateStyle:'short', timeStyle:'medium' });
const clamp  = (v,a,b)=>Math.max(a,Math.min(b,v));

/* LEDs: nombre de vert restant (le reste en rouge) */
function ledCount(remain, isOpen){
  if(isOpen){
    if(remain <= 300) return 0;                   // dernières 5 min -> tout rouge
    const eff = Math.min(3600, remain - 300);     // fenêtre 60 min
    return clamp(Math.ceil(eff / (60*12)), 0, DOTS); // ~12 min/LED
  }else{
    const seg = CLOSED_SEC / DOTS;                // ~24 min/LED
    return clamp(DOTS - Math.ceil(remain/seg), 0, DOTS);
  }
}
function nextAfter(startMs, stepMs, nowMs){
  return nowMs < startMs ? startMs : startMs + (Math.floor((nowMs - startMs)/stepMs) + 1) * stepMs;
}

/* Numéro de cycle pour un début d'OUVERTURE donné */
function cycleNumberFor(openStartMs){
  const idx = Math.floor((openStartMs - anchor_ms) / CYCLE_MS); // 0,1,2…
  return BASE_CYCLE + idx;
}

/* Rendu “live” */
let lastMinute = -1;
function render(force=false){
  const now = Date.now();

  // Où en sommes-nous dans le cycle ?
  const elapsed = (((now - anchor_ms)/1000) % CYCLE_SEC + CYCLE_SEC) % CYCLE_SEC;
  const isOpen = elapsed < OPEN_SEC;

  const phaseSec     = isOpen ? OPEN_SEC : CLOSED_SEC;
  const phaseElapsed = isOpen ? elapsed   : (elapsed - OPEN_SEC);
  const remain       = phaseSec - phaseElapsed;

  // Timers
  elUntil.textContent = fmtHMS(remain);
  elClock.textContent = fmtHMS(remain);
  elSub.textContent   = `Next transition (${isOpen ? 'close' : 'open'}) in ${fmtMMSS(remain)}`;

  // Statut
  elStatus.textContent = `Hangar ${isOpen ? 'Open' : 'Closed'}`;
  elStatus.className   = `status ${isOpen ? 'open' : 'closed'}`;
  elStatusBig.textContent = isOpen ? 'ONLINE' : 'OFFLINE';
  elStatusBig.className   = `big ${isOpen ? 'open' : 'closed'}`;

  // LEDs
  const g = ledCount(remain, isOpen);
  for(let i=0;i<DOTS;i++) leds[i].className = 'led ' + (i < g ? 'g' : 'r');

  // Prochains événements (ouver/fermet)
  const nextOpenMs  = nextAfter(anchor_ms,                CYCLE_MS, now);
  const nextCloseMs = nextAfter(anchor_ms + OPEN_SEC*1000, CYCLE_MS, now);
  elNext.textContent = `Next Close: ${pretty(nextCloseMs)} • Next Open: ${pretty(nextOpenMs)}`;

  // Tableau — on le régénère au changement de minute (suffisant) ou forcé
  const m = new Date(now).getMinutes();
  if(force || m !== lastMinute){
    lastMinute = m;
    updateSchedule(now);
  }
}

/* Tableau des 24 prochaines heures (supprime ce qui est passé) */
function updateSchedule(nowMs){
  const rows = [];
  const horizon = nowMs + 24*3600*1000;

  // Trouver le début d’ouverture le plus récent <= maintenant
  let n = Math.floor((nowMs - anchor_ms) / CYCLE_MS);
  let openStart = anchor_ms + n * CYCLE_MS;
  if(openStart > nowMs){ n--; openStart -= CYCLE_MS; }

  while(openStart < horizon){
    const closeTime = openStart + OPEN_SEC*1000;

    // On ne garde que ce qui n’est pas complètement passé
    if(closeTime >= nowMs){
      rows.push({
        cycle: cycleNumberFor(openStart),
        onAt:  openStart,
        offAt: closeTime
      });
    }
    openStart += CYCLE_MS;
  }

  // Build HTML
  let html = '<table><thead><tr><th class="cycle-cell">Cycle</th><th class="status-cell">Status</th><th class="time-cell">Local Time</th></tr></thead><tbody>';
  for(const r of rows){
    html += `
      <tr>
        <td class="cycle-cell">${r.cycle}</td>
        <td class="status-cell"><span class="tag on">Online</span></td>
        <td class="time-cell">${pretty(r.onAt)}</td>
      </tr>
      <tr>
        <td class="cycle-cell"></td>
        <td class="status-cell"><span class="tag off">Offline</span></td>
        <td class="time-cell">${pretty(r.offAt)}</td>
      </tr>`;
  }
  html += '</tbody></table>';
  scheduleDiv.innerHTML = html;
}

/* Patch date (local) */
patchDate.textContent = 'Site updated: ' + new Date().toLocaleString();

/* Boot */
render(true);
setInterval(render, 1000);
</script>
